package study.modern_java_in_action.part4.chapter14;

/**
 * Chapter 14. 자바 모듈 시스템
 */

public class Chapter14 {

    /**
     * 14.1 압력 : 소프트웨어 유추
     */

    /* 14.1.1 관심사 분리
        - "추론하기 쉬운 소프트웨어"를 만드는 것이 목표
            - 즉, 아키텍쳐 수준(고수준)에서는 기반 코드를 바꿔야 할 때 유추하기 쉽다.
        - 관심사분리(SoC, Separation of concerns)는 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙이다.
            - 서로 거의 겹치지 않는 코드 그룹으로 분리한다.
            - 패키지가 클래스를 그룹으로 나누는 것 이상으로 자바 9 모듈은 클래스가 어떤 다른 클래스를 볼 수 있는지를
              컴파일 시간에 정교하게 제어할 수 있다.
                - 자바 패키지는 모듈성을 지원하지 않는다.
        - SoC 원칙의 장점
            - 개별 기능을 따로 작업할 수 있으므로 팀이 쉽게 협업할 수 있다.
            - 개별 부분을 재사용하기 쉽다.
            - 전체 시스템을 쉽게 유지보수할 수 있다.
     */

    /* 14.1.2 정보 은닉
        - 정보 은닉은 세부 구현을 숨기도록 장려하는 원칙이다.
            - 소프트웨어를 개발할 때 요구사항은 자주 바뀐다. 세부 구현을 숨김으로 프로그램의 어떤 부분을 바꿨을 때
              다른 부분까지 영향을 미칠 가능성을 줄일 수 있다.
            - 즉 코드를 관리하고 보호하는 데 유용한 원칙이다.
        - 캡슐화(encapsulation)
            - 특정 코드 조각이 애플리케이션의 다른 부분과 고립되어 있음을 의미
            - 캡슐화된 코드의 내부적인 변화가 의도치 않게 외부에 영향을 미칠 가능성이 줄어든다.
            - 자바에서는 `private` 키워드를 통해 컴파일러를 이용해 캡슐화를 확인할 수 있다.
        - 하지만 자바 9 이전까지는 클래스와 패키지가 의도된 대로 공개되었는지를 컴파일러로 확인할 수 있는 기능이 없었다.
     */

    /* 14.1.3 자바 소프트웨어
        - 잘 설계된 소프트웨어를 만들려면, 두 가지 원칙(관심사의 분리, 정보 은닉)을 따르는 것이 필수다.
        - 자바에서는?
            - 관심사의 분리
                - 특정 패키지, 클래스, 인터페이스를 그룹으로 만들어 코드를 그룹화할 수 있다.
            - 정보 은닉
                - public, protected, private 등의 접근 제한자와 패키지 수준 접근 권한 등을 이용해 제어한다.
                - 원하는 접근 제한을 달성하기 어렵다.
                - 심지어 최종 사용자에게 원하지 않는 메서드도 공개해야 하는 상황이 발생
                - 자바 애플리케이션이 커지면서 문제가 부각되고 있다.
     */


    /**
     * 14.2 자바 모듈 시스템을 설계한 이유
     */

    /* 14.2.1 모듈화의 한계
        - 자바는 클래스, 패키지, JAR 세가지 수준의 코드 그룹화를 제공한다.
            - 클래스와 관련해 자바는 접근 제한자와 캡슐화를 지원했다.
            - 하지만 패키지와 JAR 수준에서는 캡슐화를 거의 지원하지 않았다.
        - 제한된 가시성 제어
            - public, protected, 패키지 수준, private 이렇게 네 가지 가시성 접근자가 있따.
            - 패키지 간의 가시성 제어 기능은 유명무시한 수준이다.
                - 한 패키지의 클래스와 인터페이스를 다른 패키지로 공개하려면 public 으로 이들을 선언해야 한다.
                - 결과적으로 이들 클래스와 인터페이스는 모두에게 공개된다.
        - 클래스 경로
            - 안타깝게도 애플리케이션을 번들하고 실행하는 기능과 관련해 자바는 태생적으로 약점을 갖는다.
                - 클래스를 모두 컴파일 한 다음 보통 한 개의 평범한 JAR 파일에 넣고 클래스 경로에 이 JAR 파일을 추가해 사용할 수 있다.
                - 그러면 JVM이 동적으로 클래스 경로에 정의된 클래스를 필요할 때 읽는다.
            - 클래스 경로와 JAR 조합의 약점
                1. 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없다.
                    - 다양한 컴포넌트가 같은 라이브러리의 다른 버전을 사용하는 상황에서 문제가 두드러진다.
                2. 클래스 경로는 명시적인 의존성을 지원하지 않는다.
                    - JAR 안에 있는 모든 클래스는 classes 라는 한 주머니로 합쳐진다.
                    - 즉 한 JAR가 다른 JAR에 포함된 클래스 집합을 사용하라고 명시적으로 의존성을 정의하는 기능을 제공하지 않는다.
                    - Gradle, Maven 같은 빌드 도구들이 빠진 게 있는지, 충돌이 있는지 해결하는데 도움을 준다.
        - 자바 9 이전에는
     */
}
